<!DOCTYPE html>
<html lang="is">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Mahjong Lj√≥√∞aleikur</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;0,600;1,400&family=Source+Sans+3:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: 'Source Sans 3', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            margin: 0;
            overflow-x: hidden;
        }
        .poem-font {
            font-family: 'Cormorant Garamond', Georgia, serif;
        }
        
        /* Mahjong fl√≠sar - grunnst√≠ll */
        .mahjong-tile {
            width: 58px;
            height: 72px;
            border-radius: 6px;
            box-shadow: 
                0 4px 0 rgba(0,0,0,0.3),
                0 6px 8px rgba(0,0,0,0.4),
                inset 0 1px 0 rgba(255,255,255,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.15s ease;
            position: absolute;
            user-select: none;
            font-size: 11px;
            font-weight: 600;
            text-align: center;
            padding: 4px;
            line-height: 1.2;
            word-break: break-word;
            text-shadow: 0 1px 1px rgba(0,0,0,0.2);
        }
        
        /* Litir eftir or√∞flokkum */
        .tile-nafnord {
            background: linear-gradient(145deg, #4a9eff 0%, #2563eb 100%);
            color: white;
            box-shadow: 0 4px 0 #1d4ed8, 0 6px 8px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.3);
        }
        .tile-sagnord {
            background: linear-gradient(145deg, #f472b6 0%, #db2777 100%);
            color: white;
            box-shadow: 0 4px 0 #be185d, 0 6px 8px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.3);
        }
        .tile-fornofn {
            background: linear-gradient(145deg, #a78bfa 0%, #7c3aed 100%);
            color: white;
            box-shadow: 0 4px 0 #6d28d9, 0 6px 8px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.3);
        }
        .tile-smaaord {
            background: linear-gradient(145deg, #fbbf24 0%, #d97706 100%);
            color: #1a1a2e;
            box-shadow: 0 4px 0 #b45309, 0 6px 8px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.3);
        }
        .tile-lysingarord {
            background: linear-gradient(145deg, #34d399 0%, #059669 100%);
            color: white;
            box-shadow: 0 4px 0 #047857, 0 6px 8px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.3);
        }
        
        .mahjong-tile:hover:not(.blocked):not(.matched) {
            transform: translateY(-4px);
            filter: brightness(1.1);
        }
        .mahjong-tile.selected {
            transform: translateY(-4px);
            filter: brightness(1.2);
            box-shadow: 
                0 8px 0 rgba(0,0,0,0.3),
                0 12px 20px rgba(255,255,255,0.3),
                inset 0 1px 0 rgba(255,255,255,0.5);
        }
        .mahjong-tile.blocked {
            cursor: not-allowed;
            opacity: 0.6;
        }
        .mahjong-tile.matched {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        .mahjong-tile.hint {
            animation: hint-glow 0.8s ease-in-out infinite;
        }
        @keyframes hint-glow {
            0%, 100% { 
                filter: brightness(1);
                box-shadow: 0 4px 0 rgba(0,0,0,0.3), 0 6px 8px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.3);
            }
            50% { 
                filter: brightness(1.4);
                box-shadow: 0 4px 0 rgba(0,0,0,0.3), 0 6px 25px rgba(255,215,0,0.8), inset 0 1px 0 rgba(255,255,255,0.5);
            }
        }
        
        /* Flj√∫gandi or√∞ animation */
        .flying-word {
            position: fixed;
            font-family: 'Cormorant Garamond', Georgia, serif;
            font-size: 22px;
            font-weight: 600;
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255,215,0,0.8);
            pointer-events: none;
            z-index: 1000;
        }
        
        /* Lj√≥√∞asv√¶√∞i */
        .poem-container {
            background: linear-gradient(180deg, rgba(255,255,255,0.08) 0%, rgba(255,255,255,0.03) 100%);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 16px;
            backdrop-filter: blur(10px);
            padding: 32px;
            min-height: 180px;
        }
        .poem-word {
            display: inline-block;
            transition: all 0.5s ease;
            position: relative;
        }
        .poem-word.hidden {
            color: rgba(255,255,255,0.12);
        }
        .poem-word.revealed {
            color: #f0e6d3;
        }
        .poem-word.just-revealed {
            animation: word-glow 1s ease-out;
        }
        @keyframes word-glow {
            0% { color: #ffd700; text-shadow: 0 0 30px rgba(255,215,0,1); transform: scale(1.3); }
            100% { color: #f0e6d3; text-shadow: none; transform: scale(1); }
        }
        
        /* Sigurst√≠ll */
        .victory-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            animation: fade-in 0.5s ease;
            overflow-y: auto;
            padding: 20px;
        }
        @keyframes fade-in {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .victory-content {
            text-align: center;
            color: #f0e6d3;
            max-width: 600px;
            padding: 40px;
            animation: scale-in 0.5s ease;
        }
        @keyframes scale-in {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        
        /* Stj√∂rnur bakgrunnur */
        .stars {
            position: fixed;
            inset: 0;
            pointer-events: none;
            overflow: hidden;
            z-index: 0;
        }
        .star {
            position: absolute;
            width: 2px;
            height: 2px;
            background: white;
            border-radius: 50%;
            animation: twinkle 3s ease-in-out infinite;
        }
        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
        
        /* Hnappar */
        .play-button {
            background: linear-gradient(145deg, #4a9079 0%, #2d6a5a 100%);
            border: none;
            color: white;
            padding: 12px 28px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        .play-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0,0,0,0.4);
        }
        .play-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .hint-button {
            background: linear-gradient(145deg, #fbbf24 0%, #d97706 100%);
            color: #1a1a2e;
        }
        .hint-button:hover {
            background: linear-gradient(145deg, #fcd34d 0%, #f59e0b 100%);
        }
        
        .shuffle-button {
            background: linear-gradient(145deg, #a78bfa 0%, #7c3aed 100%);
        }
        .shuffle-button:hover {
            background: linear-gradient(145deg, #c4b5fd 0%, #8b5cf6 100%);
        }
        
        /* Litask√Ωringar */
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: center;
            margin-top: 16px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: rgba(255,255,255,0.7);
        }
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }
        
        /* Hnappar√∂√∞ */
        .button-row {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: center;
            margin-top: 24px;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useMemo } = React;

        // Lj√≥√∞i√∞
        const POEM = {
            title: "Tv√¶r stj√∂rnur",
            author: "Megas",
            verses: [
                "T√≠minn l√≠√∞ur √°fram og hann teymir mig √° eftir s√©r og ekki f√¶ √©g miklu r√°√∞i√∞ um √æa√∞ hvert hann fer.",
                "En √©g vona bara hann hugsi soldi√∞ hl√Ωlega til m√≠n og lei√∞i mig √° endanum aftur til √æ√≠n.",
                "√âg gaf √æ√©r for√∞um ke√∞ju √∫r gulli um h√°lsinn √æinn, svo gleymdir √æ√∫ m√©r ekki √≠ dagsins amstri nokkurt sinn.",
                "√ç augunum √æ√≠num sv√∂rtu horfi √©g √° sj√°lfan mig um hr√≠√∞ og √©g vona√∞i a√∞ √©g fengi bara a√∞ vera √æa√∞ alla t√≠√∞."
            ]
        };

        // Or√∞flokkar
        const WORD_CLASSES = {
            nafnord: ['t√≠minn', 'r√°√∞i√∞', 'm√≠n', 'endanum', '√æ√≠n', 'ke√∞ju', 'gulli', 'h√°lsinn', '√æinn', 'dagsins', 'amstri', 'augunum', '√æ√≠num', 'hr√≠√∞', 't√≠√∞'],
            sagnord: ['l√≠√∞ur', 'teymir', 'f√¶', 'fer', 'vona', 'hugsi', 'lei√∞i', 'gaf', 'gleymdir', 'horfi', 'vona√∞i', 'fengi', 'vera'],
            fornofn: ['hann', '√©g', '√æa√∞', '√æ√∫', 'm√©r', 'sj√°lfan', 'mig', 's√©r', '√æ√©r', 'hvert'],
            smaaord: ['og', '√°', 'eftir', 'ekki', 'um', 'en', 'til', 'aftur', 'for√∞um', '√∫r', 'svo', '√≠', 'nokkurt', 'sinn', 'a√∞'],
            lysingarord: ['√°fram', 'miklu', 'bara', 'soldi√∞', 'hl√Ωlega', 'sv√∂rtu', 'alla']
        };

        const getWordClass = (word) => {
            const normalized = word.toLowerCase().replace(/[.,!?]/g, '');
            for (const [cls, words] of Object.entries(WORD_CLASSES)) {
                if (words.includes(normalized)) return cls;
            }
            return 'smaaord';
        };

        const getAllUniqueWords = () => {
            const fullText = POEM.verses.join(' ');
            const words = fullText.split(/\s+/).filter(w => w.length > 0);
            const seen = new Set();
            const uniqueWords = [];
            
            words.forEach(word => {
                const normalized = word.toLowerCase().replace(/[.,!?]/g, '');
                if (!seen.has(normalized)) {
                    seen.add(normalized);
                    uniqueWords.push(word.replace(/[.,!?]/g, ''));
                }
            });
            
            return uniqueWords;
        };

        // Skilgreina fl√≠sasta√∞i
        const getTilePositions = () => {
            const positions = [];
            const layouts = [
                { cols: 8, rows: 6, offsetX: 0, offsetY: 0, z: 0 },
                { cols: 6, rows: 4, offsetX: 1, offsetY: 1, z: 1 },
                { cols: 4, rows: 2, offsetX: 2, offsetY: 2, z: 2 },
                { cols: 2, rows: 1, offsetX: 3, offsetY: 2.5, z: 3 },
            ];
            
            const tileWidth = 62;
            const tileHeight = 76;
            const layerOffset = 4;
            
            layouts.forEach(layer => {
                for (let row = 0; row < layer.rows; row++) {
                    for (let col = 0; col < layer.cols; col++) {
                        positions.push({
                            x: (col + layer.offsetX) * tileWidth - layer.z * layerOffset,
                            y: (row + layer.offsetY) * tileHeight - layer.z * layerOffset,
                            z: layer.z,
                            row: row + layer.offsetY,
                            col: col + layer.offsetX
                        });
                    }
                }
            });
            
            return positions;
        };

        // Athuga hvort fl√≠s s√© opin
        const isTileOpenStatic = (tile, allTiles) => {
            if (tile.matched) return false;
            
            const activeTiles = allTiles.filter(t => !t.matched);
            
            const hasBlockingTileAbove = activeTiles.some(t => 
                t.id !== tile.id &&
                t.z > tile.z &&
                Math.abs(t.col - tile.col) < 1 &&
                Math.abs(t.row - tile.row) < 1
            );
            
            if (hasBlockingTileAbove) return false;
            
            const sameLevelTiles = activeTiles.filter(t => t.z === tile.z && t.id !== tile.id);
            
            const hasLeftNeighbor = sameLevelTiles.some(t => 
                Math.abs(t.row - tile.row) < 0.6 && 
                t.col >= tile.col - 1.1 && 
                t.col < tile.col
            );
            
            const hasRightNeighbor = sameLevelTiles.some(t => 
                Math.abs(t.row - tile.row) < 0.6 && 
                t.col <= tile.col + 1.1 && 
                t.col > tile.col
            );
            
            return !(hasLeftNeighbor && hasRightNeighbor);
        };

        // Finna √∂ll m√∂guleg p√∂r
        const findAvailablePairs = (tiles) => {
            const openTiles = tiles.filter(t => !t.matched && isTileOpenStatic(t, tiles));
            const pairs = [];
            
            for (let i = 0; i < openTiles.length; i++) {
                for (let j = i + 1; j < openTiles.length; j++) {
                    const word1 = openTiles[i].word.toLowerCase().replace(/[.,!?]/g, '');
                    const word2 = openTiles[j].word.toLowerCase().replace(/[.,!?]/g, '');
                    if (word1 === word2) {
                        pairs.push([openTiles[i].id, openTiles[j].id]);
                    }
                }
            }
            
            return pairs;
        };

        // Athuga hvort leikur s√© leysanlegur (einf√∂ld athugun)
        const isSolvable = (tiles) => {
            return findAvailablePairs(tiles).length > 0;
        };

        // Stokka array
        const shuffleArray = (arr) => {
            const newArr = [...arr];
            for (let i = newArr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArr[i], newArr[j]] = [newArr[j], newArr[i]];
            }
            return newArr;
        };

        // B√∫a til leik sem er tryggt leysanlegur
        const createTileLayout = (words) => {
            const positions = getTilePositions();
            const numPositions = Math.min(positions.length, words.length * 2);
            const neededWords = words.slice(0, Math.floor(numPositions / 2));
            
            let attempts = 0;
            const maxAttempts = 100;
            
            while (attempts < maxAttempts) {
                const pairs = [...neededWords, ...neededWords];
                const shuffledPairs = shuffleArray(pairs);
                
                const tiles = [];
                for (let i = 0; i < numPositions && i < shuffledPairs.length; i++) {
                    const pos = positions[i];
                    tiles.push({
                        id: i,
                        word: shuffledPairs[i],
                        wordClass: getWordClass(shuffledPairs[i]),
                        x: pos.x,
                        y: pos.y,
                        z: pos.z,
                        row: pos.row,
                        col: pos.col,
                        matched: false
                    });
                }
                
                if (isSolvable(tiles)) {
                    return tiles;
                }
                
                attempts++;
            }
            
            // Fallback - skila s√≠√∞asta tilraun
            const pairs = [...neededWords, ...neededWords];
            const shuffledPairs = shuffleArray(pairs);
            
            return positions.slice(0, numPositions).map((pos, i) => ({
                id: i,
                word: shuffledPairs[i] || neededWords[0],
                wordClass: getWordClass(shuffledPairs[i] || neededWords[0]),
                x: pos.x,
                y: pos.y,
                z: pos.z,
                row: pos.row,
                col: pos.col,
                matched: false
            }));
        };

        // Stokka √≥leystar fl√≠sar
        const shuffleUnmatchedTiles = (tiles) => {
            const positions = getTilePositions();
            const unmatchedTiles = tiles.filter(t => !t.matched);
            const matchedTiles = tiles.filter(t => t.matched);
            
            // Finna sta√∞i sem eru ekki teknir af matched fl√≠sum
            const usedPositionKeys = new Set(matchedTiles.map(t => `${t.x}-${t.y}-${t.z}`));
            const availablePositions = positions.filter(p => 
                !usedPositionKeys.has(`${p.x}-${p.y}-${p.z}`)
            );
            
            let attempts = 0;
            const maxAttempts = 50;
            
            while (attempts < maxAttempts) {
                const shuffledPositions = shuffleArray(availablePositions);
                
                const newUnmatched = unmatchedTiles.map((tile, idx) => ({
                    ...tile,
                    x: shuffledPositions[idx].x,
                    y: shuffledPositions[idx].y,
                    z: shuffledPositions[idx].z,
                    row: shuffledPositions[idx].row,
                    col: shuffledPositions[idx].col
                }));
                
                const allTiles = [...matchedTiles, ...newUnmatched];
                
                if (isSolvable(allTiles)) {
                    return allTiles;
                }
                
                attempts++;
            }
            
            // Fallback
            const shuffledPositions = shuffleArray(availablePositions);
            const newUnmatched = unmatchedTiles.map((tile, idx) => ({
                ...tile,
                x: shuffledPositions[idx].x,
                y: shuffledPositions[idx].y,
                z: shuffledPositions[idx].z,
                row: shuffledPositions[idx].row,
                col: shuffledPositions[idx].col
            }));
            
            return [...matchedTiles, ...newUnmatched];
        };

        // TTS fall
        const playAudio = async (text, onEnd) => {
            try {
                const r = await fetch('/.netlify/functions/speak', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text_to_speak: text }),
                });
                const data = await r.json();
                
                if (!r.ok || data.error || !data.audio_base64) {
                    console.error("Villa √≠ hlj√≥√∞kalli:", data.error);
                    onEnd && onEnd();
                    return;
                }
                
                const audio = new Audio(`data:audio/mp3;base64,${data.audio_base64}`);
                audio.onended = () => onEnd && onEnd();
                audio.onerror = () => onEnd && onEnd();
                audio.play().catch(() => onEnd && onEnd());
            } catch (e) {
                console.error("TTS villa:", e);
                onEnd && onEnd();
            }
        };

        // Stj√∂rnur
        const Stars = () => {
            const stars = useMemo(() => Array.from({ length: 50 }, (_, i) => ({
                id: i,
                left: Math.random() * 100,
                top: Math.random() * 100,
                delay: Math.random() * 3,
                size: Math.random() * 2 + 1
            })), []);
            
            return (
                <div className="stars">
                    {stars.map(star => (
                        <div
                            key={star.id}
                            className="star"
                            style={{
                                left: `${star.left}%`,
                                top: `${star.top}%`,
                                width: star.size,
                                height: star.size,
                                animationDelay: `${star.delay}s`
                            }}
                        />
                    ))}
                </div>
            );
        };

        // Mahjong fl√≠s
        const MahjongTile = ({ tile, isOpen, isSelected, isHint, onClick }) => {
            const tileRef = useRef(null);
            
            return (
                <div
                    ref={tileRef}
                    className={`mahjong-tile tile-${tile.wordClass} ${tile.matched ? 'matched' : ''} ${!isOpen ? 'blocked' : ''} ${isSelected ? 'selected' : ''} ${isHint ? 'hint' : ''}`}
                    style={{
                        left: tile.x,
                        top: tile.y,
                        zIndex: tile.z * 100 + Math.floor(tile.row) * 10 + Math.floor(tile.col)
                    }}
                    onClick={() => isOpen && !tile.matched && onClick(tile, tileRef)}
                >
                    {tile.word}
                </div>
            );
        };

        // Lj√≥√∞abirting
        const PoemDisplay = ({ revealedWords, wordRefs }) => {
            const fullText = POEM.verses.join(' ');
            const words = fullText.split(/\s+/);
            
            return (
                <div className="poem-container">
                    <div className="poem-font text-xl leading-relaxed">
                        {words.map((word, idx) => {
                            const cleanWord = word.replace(/[.,!?]/g, '');
                            const normalized = cleanWord.toLowerCase();
                            const isRevealed = revealedWords.has(normalized);
                            const justRevealed = revealedWords.get(normalized) === 'just';
                            const punctuation = word.match(/[.,!?]$/)?.[0] || '';
                            
                            return (
                                <span key={idx}>
                                    <span 
                                        ref={el => {
                                            if (!wordRefs.current[normalized]) {
                                                wordRefs.current[normalized] = el;
                                            }
                                        }}
                                        className={`poem-word ${isRevealed ? 'revealed' : 'hidden'} ${justRevealed ? 'just-revealed' : ''}`}
                                    >
                                        {cleanWord}
                                    </span>
                                    <span className={isRevealed ? 'text-amber-100/70' : 'text-white/10'}>{punctuation}</span>
                                    {' '}
                                </span>
                            );
                        })}
                    </div>
                </div>
            );
        };

        // Litask√Ωringar
        const Legend = () => (
            <div className="legend">
                <div className="legend-item">
                    <div className="legend-color" style={{background: 'linear-gradient(145deg, #4a9eff 0%, #2563eb 100%)'}}></div>
                    <span>Nafnor√∞</span>
                </div>
                <div className="legend-item">
                    <div className="legend-color" style={{background: 'linear-gradient(145deg, #f472b6 0%, #db2777 100%)'}}></div>
                    <span>Sagnor√∞</span>
                </div>
                <div className="legend-item">
                    <div className="legend-color" style={{background: 'linear-gradient(145deg, #a78bfa 0%, #7c3aed 100%)'}}></div>
                    <span>Forn√∂fn</span>
                </div>
                <div className="legend-item">
                    <div className="legend-color" style={{background: 'linear-gradient(145deg, #fbbf24 0%, #d97706 100%)'}}></div>
                    <span>Sm√°or√∞</span>
                </div>
                <div className="legend-item">
                    <div className="legend-color" style={{background: 'linear-gradient(145deg, #34d399 0%, #059669 100%)'}}></div>
                    <span>L√Ωsingaror√∞</span>
                </div>
            </div>
        );

        // Sigurgluggi
        const VictoryScreen = ({ onPlayAgain, onReadPoem, isReading }) => (
            <div className="victory-overlay">
                <div className="victory-content">
                    <h2 className="poem-font text-4xl mb-8 text-amber-300">‚ú® Til hamingju! ‚ú®</h2>
                    
                    <div className="poem-container mb-8">
                        <div className="poem-font text-lg leading-relaxed text-left">
                            {POEM.verses.map((verse, idx) => (
                                <p key={idx} className="mb-4 text-amber-100/90">{verse}</p>
                            ))}
                        </div>
                        <div className="mt-6 pt-4 border-t border-white/20">
                            <p className="poem-font text-xl italic text-amber-200">‚Äû{POEM.title}"</p>
                            <p className="poem-font text-lg text-white/70">‚Äî {POEM.author}</p>
                        </div>
                    </div>
                    
                    <div className="flex gap-4 justify-center flex-wrap">
                        <button 
                            onClick={onReadPoem}
                            disabled={isReading}
                            className="play-button"
                        >
                            {isReading ? 'üîä Les...' : 'üîä Hlusta √° lj√≥√∞i√∞'}
                        </button>
                        <button 
                            onClick={onPlayAgain}
                            className="play-button"
                        >
                            üîÑ Spila aftur
                        </button>
                    </div>
                </div>
            </div>
        );

        // Flj√∫gandi or√∞
        const FlyingWord = ({ word, startPos, endPos, onComplete }) => {
            const ref = useRef(null);
            
            useEffect(() => {
                const el = ref.current;
                if (!el) return;
                
                el.style.left = `${startPos.x}px`;
                el.style.top = `${startPos.y}px`;
                el.style.opacity = '1';
                el.style.transform = 'scale(1)';
                el.style.transition = 'none';
                
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        el.style.transition = 'all 0.7s cubic-bezier(0.34, 1.56, 0.64, 1)';
                        el.style.left = `${endPos.x}px`;
                        el.style.top = `${endPos.y}px`;
                        el.style.opacity = '0';
                        el.style.transform = 'scale(0.3)';
                    });
                });
                
                const timer = setTimeout(onComplete, 700);
                return () => clearTimeout(timer);
            }, [startPos, endPos, onComplete]);
            
            return (
                <div ref={ref} className="flying-word">
                    {word}
                </div>
            );
        };

        // A√∞al component
        const MahjongGame = () => {
            const [tiles, setTiles] = useState([]);
            const [selectedTile, setSelectedTile] = useState(null);
            const [selectedRef, setSelectedRef] = useState(null);
            const [revealedWords, setRevealedWords] = useState(new Map());
            const [flyingWords, setFlyingWords] = useState([]);
            const [gameWon, setGameWon] = useState(false);
            const [isReading, setIsReading] = useState(false);
            const [matchCount, setMatchCount] = useState(0);
            const [hintPair, setHintPair] = useState(null);
            const wordRefs = useRef({});
            
            const uniqueWords = useMemo(() => getAllUniqueWords(), []);
            const totalPairs = Math.min(uniqueWords.length, Math.floor(getTilePositions().length / 2));

            useEffect(() => {
                startNewGame();
            }, []);

            const startNewGame = () => {
                const words = getAllUniqueWords();
                const newTiles = createTileLayout(words);
                setTiles(newTiles);
                setSelectedTile(null);
                setSelectedRef(null);
                setRevealedWords(new Map());
                setFlyingWords([]);
                setGameWon(false);
                setMatchCount(0);
                setHintPair(null);
                wordRefs.current = {};
            };

            const handleShuffle = () => {
                const newTiles = shuffleUnmatchedTiles(tiles);
                setTiles(newTiles);
                setSelectedTile(null);
                setSelectedRef(null);
                setHintPair(null);
            };

            const handleHint = () => {
                const pairs = findAvailablePairs(tiles);
                if (pairs.length > 0) {
                    const randomPair = pairs[Math.floor(Math.random() * pairs.length)];
                    setHintPair(randomPair);
                    
                    // Sl√∂kkva √° hint eftir 2 sek√∫ndur
                    setTimeout(() => setHintPair(null), 2000);
                }
            };

            // Hreinsa just-revealed
            useEffect(() => {
                const justRevealedWords = [...revealedWords.entries()].filter(([_, v]) => v === 'just');
                if (justRevealedWords.length > 0) {
                    const timer = setTimeout(() => {
                        setRevealedWords(prev => {
                            const next = new Map(prev);
                            justRevealedWords.forEach(([word]) => next.set(word, true));
                            return next;
                        });
                    }, 1000);
                    return () => clearTimeout(timer);
                }
            }, [revealedWords]);

            // Athuga sigur
            useEffect(() => {
                if (matchCount > 0 && matchCount === totalPairs) {
                    setTimeout(() => setGameWon(true), 600);
                }
            }, [matchCount, totalPairs]);

            // Athuga hvort leikur s√© enn leysanlegur
            useEffect(() => {
                if (tiles.length > 0 && !gameWon) {
                    const unmatchedCount = tiles.filter(t => !t.matched).length;
                    if (unmatchedCount > 0 && !isSolvable(tiles)) {
                        // Sj√°lfvirk stokk ef ekkert par er til
                        setTimeout(() => {
                            handleShuffle();
                        }, 500);
                    }
                }
            }, [tiles, gameWon]);

            const handleTileClick = (tile, tileRef) => {
                setHintPair(null);
                
                if (selectedTile && selectedTile.id === tile.id) {
                    setSelectedTile(null);
                    setSelectedRef(null);
                    return;
                }

                if (!selectedTile) {
                    setSelectedTile(tile);
                    setSelectedRef(tileRef);
                    return;
                }

                const selectedWord = selectedTile.word.toLowerCase().replace(/[.,!?]/g, '');
                const clickedWord = tile.word.toLowerCase().replace(/[.,!?]/g, '');
                
                if (selectedWord === clickedWord) {
                    const word = tile.word.replace(/[.,!?]/g, '');
                    const normalized = word.toLowerCase();
                    
                    const targetEl = wordRefs.current[normalized];
                    const targetRect = targetEl?.getBoundingClientRect();
                    
                    const tile1Rect = selectedRef?.current?.getBoundingClientRect();
                    const tile2Rect = tileRef?.current?.getBoundingClientRect();
                    
                    const endPos = targetRect ? {
                        x: targetRect.left + targetRect.width / 2,
                        y: targetRect.top + targetRect.height / 2
                    } : { x: window.innerWidth / 2, y: 150 };

                    const newFlyingWords = [];
                    if (tile1Rect) {
                        newFlyingWords.push({
                            id: `${Date.now()}-1`,
                            word,
                            startPos: { x: tile1Rect.left + tile1Rect.width/2, y: tile1Rect.top + tile1Rect.height/2 },
                            endPos
                        });
                    }
                    if (tile2Rect) {
                        newFlyingWords.push({
                            id: `${Date.now()}-2`,
                            word,
                            startPos: { x: tile2Rect.left + tile2Rect.width/2, y: tile2Rect.top + tile2Rect.height/2 },
                            endPos
                        });
                    }
                    setFlyingWords(prev => [...prev, ...newFlyingWords]);

                    setTiles(prev => prev.map(t => 
                        (t.id === selectedTile.id || t.id === tile.id) 
                            ? { ...t, matched: true } 
                            : t
                    ));

                    setRevealedWords(prev => {
                        const next = new Map(prev);
                        next.set(normalized, 'just');
                        return next;
                    });

                    setMatchCount(prev => prev + 1);
                }

                setSelectedTile(null);
                setSelectedRef(null);
            };

            const removeFlyingWord = (id) => {
                setFlyingWords(prev => prev.filter(fw => fw.id !== id));
            };

            const handleReadPoem = () => {
                setIsReading(true);
                const fullText = POEM.verses.join(' ');
                playAudio(fullText, () => setIsReading(false));
            };

            const gameAreaWidth = 8 * 62 + 80;
            const gameAreaHeight = 6 * 76 + 80;
            
            const availablePairs = useMemo(() => findAvailablePairs(tiles), [tiles]);

            return (
                <div className="min-h-screen pb-12 relative">
                    <Stars />
                    
                    <header className="bg-white/5 backdrop-blur-sm border-b border-white/10 relative z-10">
                        <div className="max-w-6xl mx-auto px-6 py-6">
                            <button 
                                onClick={() => window.history.back()} 
                                className="text-sm text-white/50 hover:text-white/80 mb-2 inline-block font-light transition-colors"
                            >
                                ‚Üê Til baka
                            </button>
                            <h1 className="text-3xl font-light text-white/90 mb-1 poem-font">Mahjong Lj√≥√∞aleikur</h1>
                            <p className="text-white/50 text-sm font-light">Finndu p√∂rin og lj√≥√∞i√∞ birtist</p>
                        </div>
                    </header>

                    <main className="max-w-6xl mx-auto px-6 mt-8 relative z-10">
                        {/* Lj√≥√∞asv√¶√∞i */}
                        <div className="mb-8">
                            <PoemDisplay revealedWords={revealedWords} wordRefs={wordRefs} />
                            <div className="mt-4 text-center text-white/50 text-sm">
                                P√∂r fundin: {matchCount} / {totalPairs} ‚Ä¢ M√∂guleg p√∂r: {availablePairs.length}
                            </div>
                        </div>

                        {/* Litask√Ωringar */}
                        <Legend />

                        {/* Leiksv√¶√∞i */}
                        <div className="flex justify-center mt-6">
                            <div 
                                className="relative"
                                style={{ 
                                    width: gameAreaWidth, 
                                    height: gameAreaHeight
                                }}
                            >
                                {tiles.map(tile => (
                                    <MahjongTile
                                        key={tile.id}
                                        tile={tile}
                                        isOpen={isTileOpenStatic(tile, tiles)}
                                        isSelected={selectedTile?.id === tile.id}
                                        isHint={hintPair && (hintPair[0] === tile.id || hintPair[1] === tile.id)}
                                        onClick={handleTileClick}
                                    />
                                ))}
                            </div>
                        </div>

                        {/* Hnappar */}
                        <div className="button-row">
                            <button onClick={handleHint} className="play-button hint-button" disabled={availablePairs.length === 0}>
                                üí° V√≠sbending
                            </button>
                            <button onClick={handleShuffle} className="play-button shuffle-button">
                                üîÄ Stokka
                            </button>
                            <button onClick={startNewGame} className="play-button">
                                üîÑ N√Ωr leikur
                            </button>
                        </div>
                    </main>

                    {/* Flj√∫gandi or√∞ */}
                    {flyingWords.map(fw => (
                        <FlyingWord
                            key={fw.id}
                            word={fw.word}
                            startPos={fw.startPos}
                            endPos={fw.endPos}
                            onComplete={() => removeFlyingWord(fw.id)}
                        />
                    ))}

                    {/* Sigurskj√°r */}
                    {gameWon && (
                        <VictoryScreen 
                            onPlayAgain={startNewGame}
                            onReadPoem={handleReadPoem}
                            isReading={isReading}
                        />
                    )}
                </div>
            );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<MahjongGame />);
    </script>
</body>
</html>
