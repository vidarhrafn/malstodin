<!DOCTYPE html>
<html lang="is">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Mahjong lj√≥√∞aleikur</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;0,600;1,400&family=Source+Sans+3:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: 'Source Sans 3', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            margin: 0;
            overflow-x: hidden;
        }
        .poem-font { font-family: 'Cormorant Garamond', Georgia, serif; }
        
        .mahjong-tile {
            width: 58px; height: 72px; border-radius: 6px;
            box-shadow: 0 4px 0 rgba(0,0,0,0.3), 0 6px 8px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.3);
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.15s ease; position: absolute;
            user-select: none; font-size: 11px; font-weight: 600;
            text-align: center; padding: 4px; line-height: 1.2;
            word-break: break-word; text-shadow: 0 1px 1px rgba(0,0,0,0.2);
        }
        
        .tile-nafnord { background: linear-gradient(145deg, #4a9eff 0%, #2563eb 100%); color: white; box-shadow: 0 4px 0 #1d4ed8, 0 6px 8px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.3); }
        .tile-sagnord { background: linear-gradient(145deg, #f472b6 0%, #db2777 100%); color: white; box-shadow: 0 4px 0 #be185d, 0 6px 8px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.3); }
        .tile-fornofn { background: linear-gradient(145deg, #a78bfa 0%, #7c3aed 100%); color: white; box-shadow: 0 4px 0 #6d28d9, 0 6px 8px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.3); }
        .tile-smaaord { background: linear-gradient(145deg, #fbbf24 0%, #d97706 100%); color: #1a1a2e; box-shadow: 0 4px 0 #b45309, 0 6px 8px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.3); }
        .tile-lysingarord { background: linear-gradient(145deg, #34d399 0%, #059669 100%); color: white; box-shadow: 0 4px 0 #047857, 0 6px 8px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.3); }
        
        .mahjong-tile:hover:not(.blocked):not(.matched) { transform: translateY(-4px); filter: brightness(1.1); }
        .mahjong-tile.selected { transform: translateY(-4px); filter: brightness(1.2); box-shadow: 0 8px 0 rgba(0,0,0,0.3), 0 12px 20px rgba(255,255,255,0.3), inset 0 1px 0 rgba(255,255,255,0.5); }
        .mahjong-tile.blocked { cursor: not-allowed; opacity: 0.6; }
        .mahjong-tile.matched { opacity: 0; pointer-events: none; transition: opacity 0.3s ease; }
        .mahjong-tile.hint { animation: hint-glow 0.8s ease-in-out infinite; }
        @keyframes hint-glow {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.4); box-shadow: 0 4px 0 rgba(0,0,0,0.3), 0 6px 25px rgba(255,215,0,0.8), inset 0 1px 0 rgba(255,255,255,0.5); }
        }
        
        .poem-container {
            background: linear-gradient(180deg, rgba(255,255,255,0.08) 0%, rgba(255,255,255,0.03) 100%);
            border: 1px solid rgba(255,255,255,0.15); border-radius: 16px;
            backdrop-filter: blur(10px); padding: 32px; min-height: 180px;
        }
        .poem-word { display: inline; transition: all 0.6s ease; }
        .poem-word.hidden { color: rgba(255,255,255,0.08); }
        .poem-word.revealed { color: #f0e6d3; text-shadow: 0 0 8px rgba(255,215,0,0.2); }
        .poem-word.just-revealed { animation: word-reveal 1.2s ease-out; }
        @keyframes word-reveal {
            0% { color: #ffd700; text-shadow: 0 0 40px rgba(255,215,0,1), 0 0 80px rgba(255,215,0,0.5); transform: scale(1.4); }
            50% { color: #ffd700; text-shadow: 0 0 20px rgba(255,215,0,0.8); }
            100% { color: #f0e6d3; text-shadow: 0 0 8px rgba(255,215,0,0.2); transform: scale(1); }
        }
        
        .victory-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.85); display: flex; align-items: center; justify-content: center; z-index: 2000; animation: fade-in 0.5s ease; overflow-y: auto; padding: 20px; }
        @keyframes fade-in { from { opacity: 0; } to { opacity: 1; } }
        .victory-content { text-align: center; color: #f0e6d3; max-width: 600px; padding: 40px; animation: scale-in 0.5s ease; }
        @keyframes scale-in { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        
        .stars { position: fixed; inset: 0; pointer-events: none; overflow: hidden; z-index: 0; }
        .star { position: absolute; width: 2px; height: 2px; background: white; border-radius: 50%; animation: twinkle 3s ease-in-out infinite; }
        @keyframes twinkle { 0%, 100% { opacity: 0.3; } 50% { opacity: 1; } }
        
        .play-button { background: linear-gradient(145deg, #4a9079 0%, #2d6a5a 100%); border: none; color: white; padding: 12px 28px; border-radius: 8px; font-size: 16px; cursor: pointer; transition: all 0.2s ease; box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
        .play-button:hover { transform: translateY(-2px); box-shadow: 0 6px 16px rgba(0,0,0,0.4); }
        .play-button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        .hint-button { background: linear-gradient(145deg, #fbbf24 0%, #d97706 100%); color: #1a1a2e; }
        .shuffle-button { background: linear-gradient(145deg, #a78bfa 0%, #7c3aed 100%); }
        
        .legend { display: flex; flex-wrap: wrap; gap: 12px; justify-content: center; margin-top: 16px; }
        .legend-item { display: flex; align-items: center; gap: 6px; font-size: 12px; color: rgba(255,255,255,0.7); }
        .legend-color { width: 16px; height: 16px; border-radius: 3px; }
        .button-row { display: flex; flex-wrap: wrap; gap: 12px; justify-content: center; margin-top: 24px; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        const POEM = {
            title: "Tv√¶r stj√∂rnur",
            author: "Megas",
            verses: [
                "T√≠minn l√≠√∞ur √°fram og hann teymir mig √° eftir s√©r og ekki f√¶ √©g miklu r√°√∞i√∞ um √æa√∞ hvert hann fer.",
                "En √©g vona bara hann hugsi soldi√∞ hl√Ωlega til m√≠n og lei√∞i mig √° endanum aftur til √æ√≠n.",
                "√âg gaf √æ√©r for√∞um ke√∞ju √∫r gulli um h√°lsinn √æinn, svo gleymdir √æ√∫ m√©r ekki √≠ dagsins amstri nokkurt sinn.",
                "√ç augunum √æ√≠num sv√∂rtu horfi √©g √° sj√°lfan mig um hr√≠√∞ og √©g vona√∞i a√∞ √©g fengi bara a√∞ vera √æa√∞ alla t√≠√∞."
            ]
        };

        const WORD_CLASSES = {
            nafnord: ['t√≠minn', 'r√°√∞i√∞', 'm√≠n', 'endanum', '√æ√≠n', 'ke√∞ju', 'gulli', 'h√°lsinn', '√æinn', 'dagsins', 'amstri', 'augunum', '√æ√≠num', 'hr√≠√∞', 't√≠√∞'],
            sagnord: ['l√≠√∞ur', 'teymir', 'f√¶', 'fer', 'vona', 'hugsi', 'lei√∞i', 'gaf', 'gleymdir', 'horfi', 'vona√∞i', 'fengi', 'vera'],
            fornofn: ['hann', '√©g', '√æa√∞', '√æ√∫', 'm√©r', 'sj√°lfan', 'mig', 's√©r', '√æ√©r', 'hvert'],
            smaaord: ['og', '√°', 'eftir', 'ekki', 'um', 'en', 'til', 'aftur', 'for√∞um', '√∫r', 'svo', '√≠', 'nokkurt', 'sinn', 'a√∞'],
            lysingarord: ['√°fram', 'miklu', 'bara', 'soldi√∞', 'hl√Ωlega', 'sv√∂rtu', 'alla']
        };

        const getWordClass = (word) => {
            const normalized = word.toLowerCase().replace(/[.,!?]/g, '');
            for (const [cls, words] of Object.entries(WORD_CLASSES)) {
                if (words.includes(normalized)) return cls;
            }
            return 'smaaord';
        };

        const getAllUniqueWords = () => {
            const fullText = POEM.verses.join(' ');
            const words = fullText.split(/\s+/).filter(w => w.length > 0);
            const seen = new Set();
            const uniqueWords = [];
            words.forEach(word => {
                const normalized = word.toLowerCase().replace(/[.,!?]/g, '');
                if (!seen.has(normalized)) {
                    seen.add(normalized);
                    uniqueWords.push(word.replace(/[.,!?]/g, ''));
                }
            });
            return uniqueWords;
        };

        // B√∫a til kort fr√° or√∞i √≠ allar sta√∞setningar √æess √≠ lj√≥√∞inu
        const buildWordToIndicesMap = () => {
            const map = new Map();
            let globalIdx = 0;
            POEM.verses.forEach(verse => {
                const words = verse.split(/\s+/);
                words.forEach(word => {
                    const normalized = word.toLowerCase().replace(/[.,!?]/g, '');
                    if (!map.has(normalized)) {
                        map.set(normalized, []);
                    }
                    map.get(normalized).push(globalIdx);
                    globalIdx++;
                });
            });
            return map;
        };

        const getTilePositions = () => {
            const positions = [];
            const layouts = [
                { cols: 8, rows: 6, offsetX: 0, offsetY: 0, z: 0 },
                { cols: 6, rows: 4, offsetX: 1, offsetY: 1, z: 1 },
                { cols: 4, rows: 2, offsetX: 2, offsetY: 2, z: 2 },
                { cols: 2, rows: 1, offsetX: 3, offsetY: 2.5, z: 3 },
            ];
            const tileWidth = 62, tileHeight = 76, layerOffset = 4;
            layouts.forEach(layer => {
                for (let row = 0; row < layer.rows; row++) {
                    for (let col = 0; col < layer.cols; col++) {
                        positions.push({
                            x: (col + layer.offsetX) * tileWidth - layer.z * layerOffset,
                            y: (row + layer.offsetY) * tileHeight - layer.z * layerOffset,
                            z: layer.z,
                            row: row + layer.offsetY,
                            col: col + layer.offsetX
                        });
                    }
                }
            });
            return positions;
        };

        const isTileOpenStatic = (tile, allTiles) => {
            if (tile.matched) return false;
            const activeTiles = allTiles.filter(t => !t.matched);
            const hasBlockingTileAbove = activeTiles.some(t => 
                t.id !== tile.id && t.z > tile.z &&
                Math.abs(t.col - tile.col) < 1 && Math.abs(t.row - tile.row) < 1
            );
            if (hasBlockingTileAbove) return false;
            const sameLevelTiles = activeTiles.filter(t => t.z === tile.z && t.id !== tile.id);
            const hasLeftNeighbor = sameLevelTiles.some(t => Math.abs(t.row - tile.row) < 0.6 && t.col >= tile.col - 1.1 && t.col < tile.col);
            const hasRightNeighbor = sameLevelTiles.some(t => Math.abs(t.row - tile.row) < 0.6 && t.col <= tile.col + 1.1 && t.col > tile.col);
            return !(hasLeftNeighbor && hasRightNeighbor);
        };

        const findAvailablePairs = (tiles) => {
            const openTiles = tiles.filter(t => !t.matched && isTileOpenStatic(t, tiles));
            const pairs = [];
            for (let i = 0; i < openTiles.length; i++) {
                for (let j = i + 1; j < openTiles.length; j++) {
                    if (openTiles[i].word.toLowerCase() === openTiles[j].word.toLowerCase()) {
                        pairs.push([openTiles[i].id, openTiles[j].id]);
                    }
                }
            }
            return pairs;
        };

        const isSolvable = (tiles) => findAvailablePairs(tiles).length > 0;

        const shuffleArray = (arr) => {
            const newArr = [...arr];
            for (let i = newArr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArr[i], newArr[j]] = [newArr[j], newArr[i]];
            }
            return newArr;
        };

        const createTileLayout = (words) => {
            const positions = getTilePositions();
            const numPositions = Math.min(positions.length, words.length * 2);
            const neededWords = words.slice(0, Math.floor(numPositions / 2));
            
            for (let attempts = 0; attempts < 100; attempts++) {
                const pairs = shuffleArray([...neededWords, ...neededWords]);
                const tiles = pairs.slice(0, numPositions).map((word, i) => ({
                    id: i,
                    word,
                    wordClass: getWordClass(word),
                    ...positions[i],
                    matched: false
                }));
                if (isSolvable(tiles)) return tiles;
            }
            
            const pairs = shuffleArray([...neededWords, ...neededWords]);
            return pairs.slice(0, numPositions).map((word, i) => ({
                id: i, word, wordClass: getWordClass(word), ...positions[i], matched: false
            }));
        };

        const shuffleUnmatchedTiles = (tiles) => {
            const positions = getTilePositions();
            const unmatchedTiles = tiles.filter(t => !t.matched);
            const matchedTiles = tiles.filter(t => t.matched);
            const usedKeys = new Set(matchedTiles.map(t => `${t.x}-${t.y}-${t.z}`));
            const availablePositions = positions.filter(p => !usedKeys.has(`${p.x}-${p.y}-${p.z}`));
            
            for (let attempts = 0; attempts < 50; attempts++) {
                const shuffled = shuffleArray(availablePositions);
                const newUnmatched = unmatchedTiles.map((tile, idx) => ({ ...tile, ...shuffled[idx] }));
                const allTiles = [...matchedTiles, ...newUnmatched];
                if (isSolvable(allTiles)) return allTiles;
            }
            
            const shuffled = shuffleArray(availablePositions);
            return [...matchedTiles, ...unmatchedTiles.map((tile, idx) => ({ ...tile, ...shuffled[idx] }))];
        };

        const playAudio = async (text, onEnd) => {
            try {
                const r = await fetch('/.netlify/functions/speak', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text_to_speak: text }),
                });
                const data = await r.json();
                if (!r.ok || data.error || !data.audio_base64) { onEnd?.(); return; }
                const audio = new Audio(`data:audio/mp3;base64,${data.audio_base64}`);
                audio.onended = () => onEnd?.();
                audio.onerror = () => onEnd?.();
                audio.play().catch(() => onEnd?.());
            } catch { onEnd?.(); }
        };

        const Stars = () => {
            const stars = useMemo(() => Array.from({ length: 50 }, (_, i) => ({
                id: i, left: Math.random() * 100, top: Math.random() * 100,
                delay: Math.random() * 3, size: Math.random() * 2 + 1
            })), []);
            return (
                <div className="stars">
                    {stars.map(s => <div key={s.id} className="star" style={{ left: `${s.left}%`, top: `${s.top}%`, width: s.size, height: s.size, animationDelay: `${s.delay}s` }} />)}
                </div>
            );
        };

        const MahjongTile = ({ tile, isOpen, isSelected, isHint, onClick }) => (
            <div
                className={`mahjong-tile tile-${tile.wordClass} ${tile.matched ? 'matched' : ''} ${!isOpen ? 'blocked' : ''} ${isSelected ? 'selected' : ''} ${isHint ? 'hint' : ''}`}
                style={{ left: tile.x, top: tile.y, zIndex: tile.z * 100 + Math.floor(tile.row) * 10 + Math.floor(tile.col) }}
                onClick={() => isOpen && !tile.matched && onClick(tile)}
            >
                {tile.word}
            </div>
        );

        // Lj√≥√∞abirting - hvert or√∞ √° s√≠num fasta sta√∞
        const PoemDisplay = ({ revealedIndices }) => {
            let globalIdx = 0;
            return (
                <div className="poem-container">
                    <div className="poem-font text-xl leading-relaxed">
                        {POEM.verses.map((verse, vIdx) => {
                            const words = verse.split(/\s+/);
                            return (
                                <p key={vIdx} className="mb-3">
                                    {words.map((word, wIdx) => {
                                        const idx = globalIdx++;
                                        const cleanWord = word.replace(/[.,!?]/g, '');
                                        const punctuation = word.match(/[.,!?]$/)?.[0] || '';
                                        const state = revealedIndices.get(idx);
                                        const isRevealed = state !== undefined;
                                        const justRevealed = state === 'just';
                                        return (
                                            <span key={wIdx}>
                                                <span className={`poem-word ${isRevealed ? 'revealed' : 'hidden'} ${justRevealed ? 'just-revealed' : ''}`}>
                                                    {cleanWord}
                                                </span>
                                                <span className={isRevealed ? 'text-amber-100/70' : 'text-white/8'}>{punctuation}</span>
                                                {' '}
                                            </span>
                                        );
                                    })}
                                </p>
                            );
                        })}
                    </div>
                </div>
            );
        };

        const Legend = () => (
            <div className="legend">
                <div className="legend-item"><div className="legend-color" style={{background: 'linear-gradient(145deg, #4a9eff 0%, #2563eb 100%)'}}></div><span>Nafnor√∞</span></div>
                <div className="legend-item"><div className="legend-color" style={{background: 'linear-gradient(145deg, #f472b6 0%, #db2777 100%)'}}></div><span>Sagnor√∞</span></div>
                <div className="legend-item"><div className="legend-color" style={{background: 'linear-gradient(145deg, #a78bfa 0%, #7c3aed 100%)'}}></div><span>Forn√∂fn</span></div>
                <div className="legend-item"><div className="legend-color" style={{background: 'linear-gradient(145deg, #fbbf24 0%, #d97706 100%)'}}></div><span>Sm√°or√∞</span></div>
                <div className="legend-item"><div className="legend-color" style={{background: 'linear-gradient(145deg, #34d399 0%, #059669 100%)'}}></div><span>L√Ωsingaror√∞</span></div>
            </div>
        );

        const VictoryScreen = ({ onPlayAgain, onReadPoem, isReading }) => (
            <div className="victory-overlay">
                <div className="victory-content">
                    <h2 className="poem-font text-4xl mb-8 text-amber-300">‚ú® Til hamingju! ‚ú®</h2>
                    <div className="poem-container mb-8">
                        <div className="poem-font text-lg leading-relaxed text-left">
                            {POEM.verses.map((verse, idx) => <p key={idx} className="mb-4 text-amber-100/90">{verse}</p>)}
                        </div>
                        <div className="mt-6 pt-4 border-t border-white/20">
                            <p className="poem-font text-xl italic text-amber-200">‚Äû{POEM.title}"</p>
                            <p className="poem-font text-lg text-white/70">‚Äî {POEM.author}</p>
                        </div>
                    </div>
                    <div className="flex gap-4 justify-center flex-wrap">
                        <button onClick={onReadPoem} disabled={isReading} className="play-button">
                            {isReading ? 'üîä Les...' : 'üîä Hlusta √° lj√≥√∞i√∞'}
                        </button>
                        <button onClick={onPlayAgain} className="play-button">üîÑ Spila aftur</button>
                    </div>
                </div>
            </div>
        );

        const MahjongGame = () => {
            const [tiles, setTiles] = useState([]);
            const [selectedTile, setSelectedTile] = useState(null);
            const [revealedIndices, setRevealedIndices] = useState(new Map());
            const [gameWon, setGameWon] = useState(false);
            const [isReading, setIsReading] = useState(false);
            const [matchCount, setMatchCount] = useState(0);
            const [hintPair, setHintPair] = useState(null);
            
            const wordToIndices = useMemo(() => buildWordToIndicesMap(), []);
            const uniqueWords = useMemo(() => getAllUniqueWords(), []);
            const totalPairs = Math.min(uniqueWords.length, Math.floor(getTilePositions().length / 2));

            useEffect(() => { startNewGame(); }, []);

            const startNewGame = () => {
                setTiles(createTileLayout(getAllUniqueWords()));
                setSelectedTile(null);
                setRevealedIndices(new Map());
                setGameWon(false);
                setMatchCount(0);
                setHintPair(null);
            };

            const handleShuffle = () => {
                setTiles(shuffleUnmatchedTiles(tiles));
                setSelectedTile(null);
                setHintPair(null);
            };

            const handleHint = () => {
                const pairs = findAvailablePairs(tiles);
                if (pairs.length > 0) {
                    setHintPair(pairs[Math.floor(Math.random() * pairs.length)]);
                    setTimeout(() => setHintPair(null), 2000);
                }
            };

            // Hreinsa just-revealed
            useEffect(() => {
                const justRevealed = [...revealedIndices.entries()].filter(([_, v]) => v === 'just');
                if (justRevealed.length > 0) {
                    const timer = setTimeout(() => {
                        setRevealedIndices(prev => {
                            const next = new Map(prev);
                            justRevealed.forEach(([idx]) => next.set(idx, true));
                            return next;
                        });
                    }, 1200);
                    return () => clearTimeout(timer);
                }
            }, [revealedIndices]);

            // Athuga sigur
            useEffect(() => {
                if (matchCount > 0 && matchCount === totalPairs) {
                    setTimeout(() => setGameWon(true), 800);
                }
            }, [matchCount, totalPairs]);

            // Sj√°lfvirk stokk
            useEffect(() => {
                if (tiles.length > 0 && !gameWon) {
                    const unmatched = tiles.filter(t => !t.matched).length;
                    if (unmatched > 0 && !isSolvable(tiles)) {
                        setTimeout(handleShuffle, 500);
                    }
                }
            }, [tiles, gameWon]);

            const handleTileClick = (tile) => {
                setHintPair(null);
                
                if (selectedTile?.id === tile.id) {
                    setSelectedTile(null);
                    return;
                }

                if (!selectedTile) {
                    setSelectedTile(tile);
                    return;
                }

                const word1 = selectedTile.word.toLowerCase();
                const word2 = tile.word.toLowerCase();
                
                if (word1 === word2) {
                    // Match!
                    setTiles(prev => prev.map(t => 
                        (t.id === selectedTile.id || t.id === tile.id) ? { ...t, matched: true } : t
                    ));

                    // L√Ωsa upp √∂ll tilvik or√∞sins √≠ lj√≥√∞inu
                    const indices = wordToIndices.get(word1) || [];
                    setRevealedIndices(prev => {
                        const next = new Map(prev);
                        indices.forEach(idx => next.set(idx, 'just'));
                        return next;
                    });

                    setMatchCount(prev => prev + 1);
                }

                setSelectedTile(null);
            };

            const handleReadPoem = () => {
                setIsReading(true);
                playAudio(POEM.verses.join(' '), () => setIsReading(false));
            };

            const availablePairs = useMemo(() => findAvailablePairs(tiles), [tiles]);

            return (
                <div className="min-h-screen pb-12 relative">
                    <Stars />
                    
                    <header className="bg-white/5 backdrop-blur-sm border-b border-white/10 relative z-10">
                        <div className="max-w-6xl mx-auto px-6 py-6">
                            <button onClick={() => window.history.back()} className="text-sm text-white/50 hover:text-white/80 mb-2 inline-block font-light transition-colors">
                                ‚Üê Til baka
                            </button>
                            <h1 className="text-3xl font-light text-white/90 mb-1 poem-font">Mahjong lj√≥√∞aleikur</h1>
                            <p className="text-white/50 text-sm font-light">Finndu p√∂rin og lj√≥√∞i√∞ birtist</p>
                        </div>
                    </header>

                    <main className="max-w-6xl mx-auto px-6 mt-8 relative z-10">
                        <div className="mb-8">
                            <PoemDisplay revealedIndices={revealedIndices} />
                            <div className="mt-4 text-center text-white/50 text-sm">
                                P√∂r fundin: {matchCount} / {totalPairs} ‚Ä¢ M√∂guleg p√∂r: {availablePairs.length}
                            </div>
                        </div>

                        <Legend />

                        <div className="flex justify-center mt-6">
                            <div className="relative" style={{ width: 8 * 62 + 80, height: 6 * 76 + 80 }}>
                                {tiles.map(tile => (
                                    <MahjongTile
                                        key={tile.id}
                                        tile={tile}
                                        isOpen={isTileOpenStatic(tile, tiles)}
                                        isSelected={selectedTile?.id === tile.id}
                                        isHint={hintPair && (hintPair[0] === tile.id || hintPair[1] === tile.id)}
                                        onClick={handleTileClick}
                                    />
                                ))}
                            </div>
                        </div>

                        <div className="button-row">
                            <button onClick={handleHint} className="play-button hint-button" disabled={availablePairs.length === 0}>üí° V√≠sbending</button>
                            <button onClick={handleShuffle} className="play-button shuffle-button">üîÄ Stokka</button>
                            <button onClick={startNewGame} className="play-button">üîÑ N√Ωr leikur</button>
                        </div>
                    </main>

                    {gameWon && <VictoryScreen onPlayAgain={startNewGame} onReadPoem={handleReadPoem} isReading={isReading} />}
                </div>
            );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<MahjongGame />);
    </script>
</body>
</html>
